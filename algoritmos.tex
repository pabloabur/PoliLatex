\chapter{Algoritmos de identificação}

\begin{figure}[!h]
\lstset{keywords=[ 12 ]{frols, indice, naoPertence, para, tamanho, maximo, de, a, se, devolve, soma, e},linewidth=0.95\linewidth,literate={:=}{{$\gets$}}1 {<=}{{$\leqslant$}}1 {>=}{{$\geqslant$}}1 {<>}{{$\neq$}}1 {rho}{{$\rho$}}1   {ws}{{$ws$}}1 {w}{{$w$}}1 {gs_m}{{$gs_m$}}1 {^T}{{$^T$}}1 {^2}{{$^2$}}1 {ERR_m}{{ERR$_m$}}1 {_s}{{$_s$}}1 {theta}{{$\beta$}}1 {pmatrix}{{\ref{eq:pmatrix}}}1 {^-1}{{$^{-1}$}}1}

\begin{center}
\begin{lstlisting}[frame=single]
frols(p, y, numeroDeCandidatos, rho , termosSelecionados, s, w, A, g, err){
	para (m de 1 a numeroDeCandidatos){
		se (m naoPertence termosSelecionados){
			ws(m) := p(m); % A matriz p é definida na eq. pmatrix
			para (r de 1 a (s-1)){
				ws(m) := ws(m) - (w(r)^T * ws(m)) / (w(r)^T * w(r)) * w(r); % Gram-Schmidt Modificado
			}
			gs(m) := (y^T * ws(m)) / (ws(m)^T * ws(m));
			ERR(m) := gs(m)^2 * (ws(m)^T * ws(m)) / (y^T * y);
		}
	}
	termosSelecionados(s) := indice(ERR == maximo(ERR));
	err(s) := ERR(termosSelecionados(s));
	para (r de 1 a (s-1)){
		A(r,s) := (w(r)^T * p(termosSelecionados(s))) / (w(r)^T * w(r));
	}
	A(s,s) := 1;
	w(s) := ws(termosSelecionados(s))
	g(s) := gs(termosSelecionados(s));
	ESR := 1 - soma(err);
	se (ESR >= rho){
		s := s + 1;
		frols(p, y, numeroDeCandidatos, rho , termosSelecionados, s, w, A, g) % chamada recursiva
	}
	se (ESR < rho){
		theta := A^-1 * g;   
		devolve theta, termosSelecionados;
	}
}
\end{lstlisting}
\end{center}
\vspace{-1.3em}
\caption[Algoritmo FROLS]{Algoritmo FROLS. Este algoritmo foi implementado em forma recursiva. Os parâmetros de entrada são: p: matriz $P$ de candidatos a serem partes do modelo. Construída como na eq.~\eqref{eq:pmatrix}; y: vetor de saída $\saida$; numeroDeCandidatos: número total de termos candidatos  $M$ a serem parte do modelo (eq.~\eqref{eq:polipi}); $\rho$: parâmetro usado como critério de parada na busca por novos termos; termosSelecionados: termos já selecionados para serem parte do modelo. Inicialmente é um vetor vazio; s: registra qual a quantidade de iterações o algoritmo fez. Inicialmente s=1; $w$: matriz com os termos já selecionados ortogonalizados. Inicialmente $w$ é uma matriz vazia; A: matriz $A$ definida na eq.~\eqref{eq:Amatrix}. Inicialmente A tem dimensão 0x0; g: o vetor $g$ com os elementos definidos na eq.~\eqref{eq:gequation}. Inicialmente g é um vetor vazio; err: é um vetor com a taxa de redução de erro correspondente a cada elemento selecionado, calculado como na eq.~\eqref{eq:err}. Inicialmente err é um vetor vazio}
\label{fig:frols}
\end{figure}